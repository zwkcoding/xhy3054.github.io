---
layout: post
title: 计算机中register、cache、memory的区别
date: 2018-07-02 11:07:24.000000000 +09:00
img: memory.jpg # Add image post (optional)
tag: [计算机基础]
---
## 概念
1. register：寄存器。cpu中的基本单元，与cpu中的运算单元是一个级别的。运算单元直接处理的数据存储器。从普通单片机到intel的cpu全都存在寄存器。
2. cache：缓存。一般普通MCU是没有缓存的，一些强大的个人电脑或者手机芯片才会有缓存，缓存的一般用的是**SRAM静态随机存储器**，速度很快。通常情况是电脑在工作时将从内存中读入的用过的数据放入缓存，以便下次用时可以快速找到它。不过cpu一般不会直接访问缓存，而是先将缓存放入寄存器，再操作。
3. memory：内存。一般普通MCU也是没有内存的，而且内存一般是外置的，而缓存与寄存器通常集成在cpu内部。内存一般使用**DRAM动态随机存储器**，速度稍慢。已经工作的cpu首先会到cache寻找自己想要的数据，如果没有才会到内存读。

好比医院，医生对面的椅子就是寄存器，要看病的病人(data)就座这个椅子(register)；已经挂号的(data)进入诊室(cache)排队，其他的就在医院里（memory）。医生可以操作的就是面对面的病人，其他人要看病（如急病）也需先坐上这个位置，这是最快的。如果医生找一个人，会现在诊室(cache)里找，如果找不到，才会到医院大厅里找（memory）。

## 访问速度差异原因
1. 晶体管存储构造的不同是一个原因。SRAM静态随机存储器比较DRAM动态随机存储器速度更快，支持频率更高，但是也不易于把容量做的很大。
2. 同时内存（memory）在cpu外部，距离运算单元比较远，也算是一个原因吧。
3. 还有一个原因，就是访问方式的差异。一般寄存器（register）按位进行直接访问，速度最快；缓存（cache）与内存（memory）的访问方式一般差不多，但是缓存比较小（寻址空间小），且内存构造速度更快。

## 缓存与内存的访问方式
1. 找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）
2. 将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。
3. 将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。
4. 确定数据在哪一个内存块（chunk）上，从该块读取数据。
5. 数据先送回内存控制器，再送回CPU，然后开始使用。

> 现代多核处理器中会存在三级缓存（L1、L2与L3高速缓存）。如下是典型的多核心处理器的组织结构。
<div style="text-align: center">
<img src="{{site.baseurl}}/assets/img/data_store/多核处理器的组织结构.JPG"/>
</div>
## 总结
CPU本身只负责运算，不负责储存数据。数据一般储存在内存(memory)之中，CPU要用的时候就去内存读写数据。但是，CPU的运算速度远高于内存的读写速度，为了避免被拖慢，CPU一般都会自带一级缓存与二级缓存甚至三级缓存（cache）。基本上，CPU缓存可以看作是读写速度较快的内存。

但是，CPU缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU每次读写还需要做寻址操作，这会明显的拖慢速度。因此，除了缓存之外，CPU还自带了寄存器（register），寄存器不依靠地址区分数据，而是依靠名称来按位访问，速度最快，有的人称它为**零级缓存**。寄存器常常用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU优先读写寄存器，再由寄存器跟内存交换数据。
<div style="text-align: center">
<img src="{{site.baseurl}}/assets/img/data_store/存储器层次结构.jpg"  width="750" height="320"/>
</div>

> 存储器结构的基本思想是上一级的存储器作为下一级的高速缓存。即金字塔越往上，容量越小、速度越快、每字节造价越昂贵。

---
> 在现代计算机中，数据的读写一般是严格按照存储器层次结构进行的．比如处理器的运算单元从寄存器读取数据，寄存器从缓存读取数据，缓存从内存读取数据，内存从硬盘读取数据．当运算单元需要的数据寄存器中没有时，寄存器便会从缓存中请求该数据；如果缓存中也没有该数据，缓存便会从内存中请求该数据；如果内存中也没有该数据，内存便会从硬盘上请求该数据；然后再逐层向上返回．
