---
layout: post
title: 排序算法总结
date: 2019-04-15 10:07:24.000000000 +09:00
img:  sword/sword6.jpg # Add image post (optional)
tag: [算法与数据结构]
---

排序问题是一个基础问题，这篇博客主要总结一下各种经典常用的有特色的排序算法。

## 冒泡排序(bubble sort)
> 原理: 每次从左向右两两进行比较，将较大/小的交换到后面。每一个循环可以确定排好一个数，循环n-1次，完全排序完毕。

```cpp
void bubble_sort(vector<int> & nums){
    for(int i=0; i<nums.size()-1; ++i){
        for(int j=0; j<nums.size()-1-i; ++j){
            if(nums[j]>nums[j+1]){
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
}
```
---

> 复杂度分析: 重复n-1次循环，每次循环比较平均n/2步，因此时间复杂度是o(n^2)，空间复杂度是o(n)

## 插入排序(Insertion sort)
> 原理: 循环n-1次，每次将当前的(从1开始)数插入到前面已经排序完毕序列中合适的位置。

```
void insert_sort(vector<int> &nums){
    for(int i=1; i<nums.size(); ++i){
        for(int j=i; j>0 && nums[j]<nums[j-1]; --j){
            int temp = nums[j];
            nums[j] = nums[j-1];
            nums[j-1]= temp;
        }
    }
}
```
---

> 复杂度分析: 重复n-1次循环，每次循环平均n/4步，因此时间复杂度是o(n^2),空间复杂度是o(n)

## 选择排序(selection sort)
> 原理: 每次从乱序数组中找处最大(小)的那个值，将其放在当前乱序数组的头部，最终使得数组有序

```
void selection_sort(vector<int> &nums){
    for(int i=0; i<nums.size()-1; ++i){
        int min=i;
        for(int j=i+1; j<nums.size(); ++j){
            if(nums[j]<nums[min])   min=j;
        }
        int temp = nums[i];
        nums[i] = nums[min];
        nums[min] = temp;
    }
}
```
---

> 复杂度分析: 重复n-1次循环，每次循环平均n/2步，因此时间复杂度是o(n^2)，空间复杂度是o(n)

## 希尔排序(shell sort)
插入排序的改进版，是一种非稳定排序算法。插入排序的特点:
1. 插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率
2. 但一般情况下，插入排序是低效的，因此每次只将数据移动一位

希尔排序通过多次插入排序，提升插入排序的性能，实例如下:

- 对于一组数`13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10`

- 首先设置步长为5，则这组数可以如下表示，一共将数据分成了5组
```
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
``` 
- 然后对于每组(列)进行插入排序，得到
```
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```
- 上述数组现在变为`10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45`

- 此时设置步长为3,将数据分成了3组
```
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```
- 对上述每组(列)进行插入排序，得到
```
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```
- 最后再以1为步长进行插入排序，就可以得到正确结果了。

> 希尔排序无论初始步长是多少，也无论中间步长是多少，只要最后一遍步长为1，最后的结果就肯定是正确的。前面那么多次的排序只是为了减少最后一次排序的时间。

```cpp
//此处步长设置为每次2倍递减
void shell_sort(vector<int> &nums)
{
    for (int gap = nums.size() >> 1; gap > 0; gap >>= 1) { 
        for (int i = gap; i < nums.size(); i++) { 
            int temp = nums[i];

            int j = i - gap;
            for (; j >= 0 && nums[j] > temp; j -= gap) {
                nums[j + gap] = nums[j];
            }

            nums[j + gap] = temp;
        }
    }
}
```
---

> 复杂度分析: 希尔排序的复杂度与步长选择有很大关系，最坏情况为o(n^2)，最好复杂度为o(n(logn)^2)，目前已知最好步长序列是(1,5,19,41,109,...)


## 归并排序(merge sort)


## 快速排序(fast sort)


## 堆排序(heap sort)



