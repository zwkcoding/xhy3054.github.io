---
layout: post
title: 补码，原码，反码
date: 2018-04-24 10:07:24.000000000 +09:00
img:   image.jpg # Add image post (optional)
tags: [计算机基础]
---

## 写作缘由

昨天室友忽然提到老师布置的作业里有关补码的问题，我竟然有些生疏了，张口结舌说忘了。事后想到这是最基础的内容了，不由老脸一红。赌气般的把这个问题又梳理了一遍。想来想去觉得还是写出来吧，加深记忆，随时翻阅，省的再给忘了。


## 有符号数与无符号数

首先，无符号数是最简单的，例如一个八位的无符号数取值范围为`0～255`。

而有符号数最高位为符号位，所以一个八位的有符号数取值范围为多少呢（先卖个关子）？计算机中存储的都是有符号数，也叫**机器数**。机器数`10000001`的**形式值**为129，**真值**为`-1`。

下文中说的都是对于八位有符号数，因为无符号数讨论补码原码什么着实没什么意义，更多位数的如16位有符号数可以自己类推。


### 原码

原码：符号位 + 绝对值

所以八位机器数的原码范围为`11111111 ～ 01111111`，也就是`-127～127`（0有两种表示）。

这种形式及其符合人们脑海中对于有符号数的第一印象，看到这里都会觉得理所当然，确实，这是人脑最容易理解与计算的形式。但，对电脑不是。


### 反码

反码：
- 首先记住，符号位是不会变得，正数最高位为0，负数最高位为1
- 正数的反码为本身
- 负数的反码是其原码符号位不变的基础上，其余各位取反

反码有什么用呢？

计算机只会做加法，不会做减法，反码可以用来实现机器减法，没错，而且这个减法是完备的，在负数域，可用的，只是有一个小小的缺点而已，如：

	1 - 1 = 1 + （-1） = 反[00000001] + 反[11111110] = 反[11111111] = 原[10000000] = -0

其他的数大家也可以试试，在结果是负数或0时都成立的，但是在结果是正数时，我们会发现结果刚好小1。例如

	3 - 1 = 3 + （-1）=反[00000011] + 反[11111110] = 反[00000001] = 原[00000001] = 1

这个原因我们仔细考虑一下会发现，在采用反码的减法中，负数通过加正数得0时得到的是`-0`，而且刚好`-0 +1 = +0（本来应该是1的）`。如何解决这个问题呢？我们来看补码。


### 补码

补码：
- 同样，符号位始终不变，正数最高位为0，负数最高位为1, 而0的补码为`00000000`（原来的负0在补码里变成了-128），所以补码表示范围`-128~127`
- 正数的补码为本身
- 负数的补码是其原码在符号位不变的基础上，其余各位取反加1（也就是反码的基础上加1）

下面来讨论上面的问题，用补码来实现机器减法：如：

	1 - 1 = 1 + （-1） = 补[00000001] + 补[11111111] = 补[00000000] = 原[00000000] = 0

由于补码实现的减法得到的结果不是-0而是0了，反码的那个问题便解决了。只是需要说明的是原来的`-0`即`10000000`现在干嘛去了呢？对，它现在是`-128`，而这个数（-128）只存在补码表示，不存在原码和反码表示。编程里常用的32位有符号int取值范围是`[-2^31 ～ 2^31 -1]`，没错，都是补码存储的。

`10000000`看作原码是-0;求反码是`11111111`，再求补码是`10000000`（求补码时加一是不进最高位的，但是补码还有反码减法时最高位符号位是会进位的），不过此时代表-128。

### 神奇补码背后思考

> 其实仔细想想补码这样定义确实是有其原因的。（当然，只是我个人理解用的）

我们都知道加法减法是满足结合率的，所以要想知道做减法需要用到的负数机器码应该如何定义可以这样想：

	原数 + a - a = 原数
	+a + （-a) = 0
	
- 所以会有`1 + （-1）= 0`，我们知道1为`00000001`，所以-1应该为`11111111`
- 同理，2为`00000010`，-2应该为`11111110`
- 。。。依次类推，补码也诞生了，这种实现减法的思想依靠的是有限位数进位导致的循环来实现的。在8位二进制数中，减1也就等于加255，刚好是求补的感觉，所以这种编码方式叫做补码（我猜的）。

> 亮点：计算机中数都是补码存储的，计算机的加法计算也没有什么弯弯绕绕，就是很耿直的进位加法，补码这种形式刚好可以使得加法计算的结果正确无误，无非就是靠进位导致的循环来实现罢了。很多人只是不熟悉而已，熟悉了在分析此类问题时会自动先将数据切换成补码形式，任何问题都会一目了然。



**现在我们可以想一下并发现，如果8位计算溢出了，大于127比如结果为`127+n`（n>0且n<=256），8位存储的数会变成`-129+n`（从-128到127）;小于-128比如结果为`-128-n`（n>0且n<=256）,8位存储的数会变成`128-n`（从127到-128）。这就是一个完美循环。**

其实这没有什么不好理解的，你只需要想清楚，在计算机中，数据都是补码形式存储的。计算机做加法操作其实就是不断进位喽。如果你还是觉得不太直观，写个c语言程序验证一下，我的`c_learn`文件夹下`ch3`目录就写了一个很简短的验证。


## 总结
一般情况下，以上这些已经足够了，为了不会闹笑话，我们来检验一下：

-8的补码是多少？
